How does quantum computing work?
Dan Piponi did a great job of explaining the first question for the quantum logic/gate model of quantum computing. If you'd like to see a laymen's explanation for adiabatic quantum computing, such as the machine that was built by D-Wave, you can check out my answer to this question: How does adiabatic quantum computation work in layman's terms? For this answer though, I'm going to answer the second (and, briefly, the third) question, which is stated as follows: What kinds of problems quantum computing could help solve? First, let me start off by saying that there are two main paradigms right now for quantum computing, and they are the quantum circuit or gate model and the quantum adiabatic model (actually there are more than just two (see: Hadayat Seddiqi's answer to What are some hot topics in quantum computing research? for a discussion on this), but these are the most serious experimental implementations so far). If you have heard of the company D-Wave and their quantum computer, you're looking at a machine that is of the latter type. Most physicists and engineers working in quantum computing are working on the former type. They are, however, equivalent, as this paper shows: [quant-ph/0405098] Adiabatic Quantum Computation is Equivalent to Standard Quantum Computation So someone could conceivably also factor large numbers if they found an equivalent adiabatic version to Shor's algorithm, but it wouldn't necessarily be as fast as the circuit model would allow, nor would it necessarily be even faster than classical computation. This is an important point to realize about quantum computing. Adiabatic, quantum gate, classical silicon, these are all different paradigms of computation. Some are faster than others with certain problems. Quantum computing is not better at all algorithms than everything else we've got. There are a number of problems that both QC paradigms seriously fail at.. but of course I'm going to focus on the ones that it do well. That being said, it's interesting to note that a naive implementation of the adiabatic quantum optimization algorithm gives only a [math]\mathcal{O}(n)[/math] time complexity for unstructured search (where quantum circuits give [math]\mathcal{O}(\sqrt{n})[/math]), but this is only true if you're not a little clever about it, see [quant-ph/0107015] Quantum Search by Local Adiabatic Evolution (by the way, adiabatic quantum computing, quantum optimization, quantum annealing, and similar names roughly refer to the same thing in the context of such an overview) Quantum Circuit/Gate Model See Debo Olaosebikan's answer, since he pretty much covers most of what current research provides. To be brief, there is Shor's algorithm for factoring large numbers, Grover's search algorithm which allows you to do a "needle in a haystack" sort of search, and a quantum Fourier transform (an excellent explanation of which is given here Debo Olaosebikan's answer to How does Quantum Fourier Transform work?). A brief intuitive (but definitely not rigorous) picture is simple if you know a little bit about quantum mechanics. In classical probability, you have two "ways" to do something that raise the total probability of that result. In quantum, you have probabilities that are represented by complex numbers rather than reals (like in classical prob.), which means that having more than one way to do something doesn't necessarily make it more probable, in fact these complex numbers are called probability amplitudes, and they can "interfere" constructively, as you might think, but also destructively. This interference helps with unstructured search, for example, because what you do is you manipulate your inputs in such a way so that wrong answers "cancel" each other out until only the correct answer has a high probability of being measured. Adiabatic Model So factoring large primes seems like the big thing with quantum computing, but I would argue that problems that the adiabatic model can solve are about as important, if not moreso. If you are interested in how adiabatic quantum computing (AQC, henceforth) really works, I'll again refer you to this question: How does adiabatic quantum computation work in layman's terms? Anyway, the type of problems that AQC's are very good at are optimization problems. Check this wiki for a brief moment if you'd like: Boolean satisfiability problem. Basically, it's an algebraic or Boolean expression that looks like ( ^ means and, v means or, funny sideways L means not): Now you can convert this into algebraic form if you like, so that ANDs are the multiplication  (*), ORs are addition (+), negation could be negative (-), etc. Then you have an algebraic expression. You can take that expression and represent it in summation form. All of these are details. With all of that theoretical crap out of the way, what are optimization/satisfiability problems? Think for example of trying to find the shortest path on a map from one city to another. If you wanted to do a brute-force search, you'd be trying every single possibility that existed. Another example is the knapsack problem, where you have a bunch of items but you can only carry a certain amount. What's the value of each item versus its weight? Maybe you're NASA and you're building a rocket, and you're trying to figure out how much fuel to put on the rocket. But remember fuel adds weight, so what are the optimal fuel to payload ratios? Perhaps you are studying protein folding, and you need to fold in the minimum energy conformation so that you can understand how diseases work (nature doesn't always get to the minimum, e.g. mad cow disease, sickle cell anemia). Massive problem with tons of simulated parameters. Or what if you needed to schedule a flight? Oh but your plane will be 2 hours away from this city at that time, and there are other incoming flights that need gates as well, and you need to refuel somewhere, and.... So you can see that searching through every possibility for detailed problems is totally impractical (and all of the ones I mentioned are much more intricate than how I've explained). At the moment, we do alright with heuristics and approximations, but we could always do better. However, adiabatic quantum computing gives us a way to do these problems potentially much faster than classical computers. The trick lies in quantum tunneling. This figure makes that idea most obvious: Imagine the black function as a hill. In our classical world, there is no way to get from one minima to another without walking over the hill. This is what all classical solver techniques must do, whether it's simple hill-climbing, simulated annealing, or genetic algorithms. Quantum annealers, however, can tunnel through sufficiently thin barriers (depending on the tunneling amplitude of the particle). You can intuitively see how much work it would take to go up that hill, and why it's not probable that any solver will know to do that, especially if it has no knowledge that the global minima is right over the edge. But it's effortless for the quantum particle, so this is helpful. Briefly, ere is a small list of problems and application areas that could potentially be solved much more quickly with an AQC: Protein folding Shortest paths on a map Manufacturing and logistics Machine learning and AI Containment problem in nuclear fusion (materials simulation) Traffic engineering Computer vision (e.g. anomaly detection) Search ranking Image/video/data compression Scheduling of any sort (airline, events, computer process, etc.) Automatic theorem provers And of course there are things that if we are able to do, like linear algebra, that will increase any real list like this by many, many times. Can't be that easy, can it? Sorry, no. Mapping a problem to a basic Boolean satisfiability problem is really, really hard. Some problems you wouldn't want to convert to that form anyway (imagine a problem that requires the number of qubits to scale with the number of real variables by a polynomial of high degree, or worse, exponentially). Or you might find that an approximate solver is not good when you have hard constraints that must not be violated (these machines operate at finite temperature, so there is always noise). It's all about being smart and knowing what sort of problems this paradigm will be good at. That being said, it can be a very useful tool in the future once we begin to understand it more. In terms of practicality, D-Wave has already built a 128-qubit AQC (as of early 2014, Google/NASA Ames share a 512-qubit machine), so on that front we are good. They're still trying to improve accuracy and such things, but their main goal is to get good answers within some tolerable tolerance. They've got big customers (Lockheed Martin, possibly Google in the future) wanting a piece of this, and they're looking like they're making a lot of progress. It is indeed a very exciting area of research to follow. However, we should be careful as the D-Wave PR machine is known to.. bend the truth at times, to put it lightly. See: Why is there so much controversy around the D-Wave Quantum Computer? How to correct errors? Well, this one is pretty easy in theory for AQC. If you understand how this type of QC works, you'll see that all you need to do is run your computer for a longer time. The adiabatic theorem tells you that the longer you wait for your system to reach its final state, the more likely you are to have stayed in the ground state (or, said another way, the less likely you are to have excitations, which basically translate to errors). If you ran it for T = infinity, you'd be 100% accurate. Of course, experimentally there will be many more challenges. In theory, we assume that we have no stray magnetic fields, for example, that we're in the ground state always so we're ultra cold, etc. Many things that I'm no good at, as I'm not an experimentalist, but any physicist who works with superconductors can tell you (though I suppose you could implement an AQC with something other than superconductors, but I'm not aware of any good candidates for that yet). As Dan mentions in his comment below, there are practical problems for why having an arbitrarily long annealing schedule is not helpful. So in the face of these problems, there are more sophisticated methods we have to employ. It's hard to give intuition about how this error correction works, but imagine that you define different spaces for coding, errors, and your problem, and if the solution is tending towards anything besides what you want, you penalize this somehow in your objective function. Here are some papers: [quant-ph/0512170] Error correcting codes for adiabatic quantum computation and [quant-ph/1307.5893] Error suppression and error correction in adiabatic quantum computation I: techniques and challenges. Updated 104w ago • View Upvotes