Is it best practice to write functional or object orientated JavaScript?I have been programming in JavaScript, mainly node.js, for about 6 months now and am still unsure if it is best to write my code with an object orientated approach or a functional approach. Is there a standard way, the go to when unsure as to which to choose. I wish to further develop my skills beyond beginner/intermediate and believe I should develop my skills in one of these paradigms.
Object Orientation and Functional aren't mutually exclusive concepts, so you don't really have to choose one or the other. In fact, they're very much complementary. OOP techniques can be used for organising programs into modular components, and combining these components with each other, whereas FP techniques can be used for modelling data structures and transforming them. Erlang is a good example of this, where pure functions are used inside a module, and components are expressed as actors that are combined by message passing. Given that, I'll try explaining a bit of both sides, and how you can combine the two in JavaScript, to take advantage of them. Note, however, that the only thing you should really be interested in is "techniques," rather than buying into a narrow philosophy of how programs should be written. You can switch between techniques and choose the one that feels most adequate for a particular situation, you can't switch philosophies as easily. The more techniques you know, the more powerful and natural combinations you'll be able to come up with for all problems you want to solve. Why Functional Matters?Functional Programming is a model of computation where computations are exclusively expressed by the combination of (mathematical) functions. Mathematical functions are required to be pure, that is, they must not have any kind of side-effect (no mutation, no writing files, no talking to databases, no nothing). An increasing number of programs said to be functional are, of course, not functional at all, they just happen to incorporate functional techniques. Languages are called "functional" when they encourage, and have a good support for expressing your programs in the functional model. JavaScript is not a functional language, however you can apply functional techniques to programs written in it. Haskell is a functional language, but programs written in Haskell will not necessarily be functional. The major benefits from buying into the functional philosophy are correctness, compositionality, and static reasoning, which helps with testing, debugging, and similar tasks. Incorporating techniques from functional programming will give you varying levels of these benefits. Algebraic Data Types Programs manipulate data. And it is easier to make these manipulations correct if the data you're manipulating fully encodes all of its possibilities in your application's model. In order to do so, it's important to understand how data types in programming languages help in building software. Data types aren't a concept of functional programming, nor are ADTs, but the latter is mostly used in functional contexts. ADTs allow one to properly encode the possibilities of the data in your program by giving you powerful tools for modelling compound data structures (product types), and one-of data structures (sum types). While, in theory, lazy languages don't have real sum types and eager languages don't have real product types, in practice this doesn't really matter, as you still get the benefits of properly modelling your data structures into sums and products, rather than just using products, as commonly done in JS. While it's very easy to encode products in JS (objects are naturally products), the language doesn't have a natural support for sums. You can still encode sums structurally: function NotFoundError(id) { this.id = id; } function Success(value) { this.value = value; } function DatabaseError(reason) { this.reason = reason; } // This is like "enum" in languages that have it // but supports each case holding arbitrary values too! var ResultCases = { NotFoundError: NotFoundError, Success: Success, DatabaseError: DatabaseError } // This function forces you to handle the errors in order // to get to the value, which helps in making the program // correct. function getUser(id) { if (database.has(id)) { try { return new ResultCases.Success(database.get(id)) } catch (e) { return new ResultCases.DatabaseError(e) } } else { return new ResultCases.NotFoundError(id) } } Pattern Matching Functional languages support pattern matching, a feature that allows one to tear apart complex data structures in a correct way. Compare: function invert(tree) { if (tree.isBranch) { return new Branch(invert(tree.right), invert(tree.left)) } else { return new Leaf(tree.value) } } With: invert (Branch left right) = Branch (invert right) (invert left) invert (Leaf value) = Leaf value The Haskell code, which uses pattern matching, is much clearer on the intent of the code. Furthermore, the JavaScript snippet defines implicit relationships that can be easily violated. What if an object has the property `isBranch` set to true, but has only a `left` property, or has instead of left/right, a `value` property? It also assumes that anything doesn't have `isBranch` set to true is going to be a Leaf node, which might not be true either. While JavaScript does not support pattern matching, short of using something like natefaubion/sparkler with Sweet.js macros, it's possible to have a limited form of it by using dynamic dispatch on objects, which solves the above problem: function Branch(left, right) { this.left = left; this.right = right; } Branch.prototype.match = function(pattern) { return pattern.Branch(this.left, this.right); } function Leaf(value) { this.value = value; } Leaf.prototype.match = function(pattern) { return pattern.Leaf(this.value); } function invert(tree) { return tree.match({ Branch: (left, right) => new Branch(invert(right), invert(left)), Leaf: (value) => new Leaf(value) }) } Pure Functions Functional programming is all about pure functions. While in JS you don't get the compiler to enforce purity, or optimise for it in a lot of cases, besides inlining, pure functions help with testing and debugging, by reducing the amount of state you need to care about for any particular part of your program. Pure functions are lovely. Use them whenever possible. Recursion Patterns A lot of algorithms are naturally expressed through recursion. And transforming data structures is very natural with structural recursion, as exemplified by the function inverting binary trees above. Given this, a good understanding of Recursion Patterns, in particular Catamorphism (or Fold/Reduce), helps a lot with implementing these transformations in terms of operations that are already available to you in the standard library, or common libraries, such as LoDash or Ramda. Why Object Orientation Matters?Object Oriented Programming is a model of computation where computations are exclusively expressed by communicating objects. Objects, in this context, are first-class entities that have dynamically dispatched behaviour. Most of the programs said to be Object Oriented are, of course, not Object Oriented at all, they just happen to incorporate Object Oriented Programming techniques. Again, we call languages "Object Oriented" when they encourage, and have good support for writing programs in the OOP model. JavaScript is not an Object Oriented language, however you can apply Object Oriented techniques to programs written in it. Smalltalk is an Object Oriented language, but programs written in Smalltalk will not necessarily be Object Oriented. The major benefits from buying into the Object Oriented philosophy are discoverability (given a reflective environment), modularity, and polymorphism¹, which helps organising programs into logical units, and composing them. Incorporating techniques from Object Oriented programming will give you varying levels of these benefits. Dynamic Dispatching Dynamic dispatching is the most important thing in Object Oriented programming. Basically, this means that computations are selected at runtime, depending on the values, rather than statically, depending on the types, static scope, or syntactical structure. This particular feature allows writing generic code on top of an interface, rather than the shape of a particular value. This is very important when you consider modular units of code. For example, suppose you want to write a function that filters any kind of collection. Collections have the most varying forms of storing their values, so it's not possible to write a parametric polymorphic function to handle this case. With Dynamic Dispatching, you can, instead, write several different computations, one for each value, and select between them depending on the value of the collection. In JavaScript, the dispatch is limited to a single value, and it happens when you project a particular property from an object (object.property, or object['property']). This allows us to come up with the following: // filter can be applied to any monad function filter(collection, predicate) { return collection.flatmap(function(value) { return predicate(value)? collection.of(value) : collection.empty() }) } Array.prototype.of = function(value) { return [value] } Array.prototype.empty = function() { return [] } Array.prototype.flatmap = function(f) { return [].concat.apply([], this.map(f)) } filter([1, 2, 3, 4], (a) => a % 2 === 0) // => [2, 4] function Maybe() {} Maybe.prototype.empty = function() { return new Nothing() } Maybe.prototype.of = function(value) { return new Just(value) } function Nothing() {} Nothing.prototype = Object.create(Maybe.prototype); Nothing.prototype.flatmap = function(f) { return this; } function Just(value) { this.value = value; } Just.prototype = Object.create(Maybe.prototype); Just.prototype.flatmap = function(f) { return f(this.value) } filter(new Nothing(), (a) => true) // => Nothing filter(new Just(1), (a) => a === 2) // => Nothing filter(new Just(2), (a) => a === 2) // => Just(2) More powerful techniques, such as multi-methods, multi-dispatching, and predicate dispatching can be easily encoded in JavaScript, although it's harder to optimise them. Modules Another very important technique in Object Orientation is modules. Modules are implementations of a particular interface (for example, Array could be a module if we define an interface for it). The good thing about modules is that they have well-defined interactions and dependencies (even better if you have a structural type system to encode these constraints), and they allow one to just replace implementations of modules without affecting any other part of the code. Ironically, most of the research on Modules has been done in the functional language ML, although the work on Newspeak is also very interesting. In JavaScript, objects are naturally modules, and it's easy to write code for a particular interface, as demonstrated above in the Dynamic Dispatching section. Furthermore, since JavaScript uses a prototype-based OO model, where you only have objects, and objects define their own set of behaviours, encoding more powerful things like (generative) parametric modules is very natural: just write a function that takes in the dependencies for the module and returns an object that uses those dependencies. This allows, for example, avoiding tying your program to a particular implementation, or worse, tying your program to a very specific external system, making it very hard to test. Compare: var fs = require('fs'); module.exports = { read: function(path) { return fs.readFileSync(path, 'utf-8') } } With: module.exports = function(fs) { return { read: function(path) { return fs.readFileSync(path, 'utf-8') } } } The second code only depends on a module that fulfills the interface "{ readFileSync: (pathname, encoding) -> String }", not on the actual file system. Testing this module, then, becomes trivial: you just pass an object that generates random strings, rather than reading things from the file system directly. Doing an integration test is just as trivial: just pass the correct file system module. Supporting different platforms also becomes trivial: pass a file system module for that particular platform, rather than Node's built-in one. Unfortunately, ES6 modules are second class, and do not have a natural support for (generative) parametric modules, although it would be possible for them to (ML modules are second class, after all). I've stopped following the ES discussions, so I'm not sure if parametric modules are planned. None the less, they are trivial to encode with objects. ConclusionWhile Functional programming and Object Oriented programming, as computational models, may be incompatible, the techniques used by them aren't. JavaScript does not really optimise for one or the other, so it's possible to mix-and-match the two without many problems. You'll not get all of the benefits of Functional languages by using functional techniques in JS, and you'll not get all of the benefits of Object Oriented languages by using OO techniques in JS, but you'll get a lot of the benefits here, and you can mix-and-match different techniques to avoid problems that only occur in one of the models (such as the Expression Problem). Footnotes ¹: There are many forms of polymorphism. Functional programming tends to, usually, use a lot of parametric polymorphism, whereas Object Oriented programming tends to use a lot of subtyping polymorphism and ad-hoc polymorphism. I didn't know how to contrast the two here, but mostly I meant that OO helps making ad-hoc polymorphism (specially when you consider open classes, or things like protocols) less of a hassle. Updated 10 Sep • View Upvotes