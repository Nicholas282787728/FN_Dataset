How can I get a job at Facebook or Google in 6 months?How should I be going? I need a concise work-plan to build a good enough skill set. Should I join some other start-up? Should I build my own projects or start-up? Should I just focus on practicing up on Data Structures and Algorithms ?
This, of course, is according to my opinion and experience. YMMV, but I hope it helps: The most important part that people often overlook:I always say that 30 minutes of study a day is way better than 3h 30min once a week. Study often, the body works in a use-it-or-lose-it fashion. There's no need to study for 8-10 hours straight, I would in fact discourage that because of the risk of burnout. Plan small sessions, plan small and big intervals during the day. Make these intervals flexible (don't go on a big interval if you feel like keeping up; don't stop for only 15 minutes if you're really tired). Get plenty of rest, specially a good night of sleep - that's when the brain stores information. Nobody thinks clearly when they are tired or hungry (that goes for interviews too). Don't go to sleep right after a session of intense brain workout, it takes a while to turn it off. Stop at least two hours before going to bed and do nothing or at least something relaxing (not video-games, they are usually stressing like any other challenging activity). Just don't ignore the signals you receive from your body and don't try to enter hero-mode, just keep your pace and aim for steady progress. When studying the algorithms, data structures and the solution to interview questions, never ever try to memorize the code. You should instead focus on understanding how and why the solution works. What's the motivation behind the problem? How could you use it to solve real-world problems? What are the insights, the clever observations made on the problem's constraints that make the solution possible? What details of the problem does the solution take advantage of to get that extra performance gain / space saving? Where does the algorithm / data-structure / solution suck? How could you make it better? What do you lose and gain by doing so? For the specific problem at hand, which solution presents the most acceptable trade-offs? Don't focus too much on the end goal, the whole process should be rewarding. If you're not enjoying prepping for the interviews, chances are you're doing it wrong, for the wrong reasons or you're simply pursuing the wrong career. Learning, understanding, overcoming the challenges and getting better at stuff is awesome by itself, getting the job is just a nice consequence of your good work. Remember: you're not only trying to get the job, you also want to keep it afterwards and it will probably not be too different from what you're already doing while studying. You're also not done when you get the offer - in fact, you're never done. Be humble. Nobody learns what they think they already know. Nobody improves what they think they're already good at. The only competition you have is yourself so be honest with you. Leave your ego outside the door. If you think you're ready for the interview because you know enough, you probably need to prep some more (http://en.wikipedia.org/wiki/Dun...). If you think you're not ready, that might not mean anything (http://en.wikipedia.org/wiki/Imp...). Don't quit if you fail an interview. Instead, try to identify and learn from your mistakes. The interviewing process is also not perfect, false negatives do happen. Just like every technical problem you'll have to solve during the interviews, the biggest difference lie in the smallest details. That's what this section is all about, the details that we don't always think about but that silently impact the final result. Format of the interviews:Most interviews for software engineering roles are divided into basically three categories: (1) behavioral / culture fit, (2) systems design and (3) programming / algorithms. Most of the time you'll be interviewed for (3), but the same interviewer might be evaluating you for more than one category at the same time. As far as (1) is concerned, it helps to put yourself in the interviewer's position and ask yourself: would I want to work with this guy everyday for the next year? Would I have a beer with him or invite him to lunch and talk about my weekend? Will I and the rest of the company be able to rely on him as a peer? The importance given to (2) is directly proportional to the experience you have in the industry. As a new grad, you shouldn't worry too much about it but don't neglect it either. Keep this format in mind while you study because it kinda reflects the daily work you'll do if you get the job. That's the interview purpose in the first place, right? See if you're a fit for the role. Where to find study material: this blog is amazing, it not only lists several technical problems, but also propose different approaches to solve it while providing a nice explanation: GeeksforGeeks - A computer science portal for geeks this is a list of interview questions I compiled when I was in a similar situation to yours: https://github.com/juchem/prep I don't want to sound like a douche who quotes himself, but I've written a somewhat similar answer that might be of some help: Marcelo Juchem's answer to How do you keep your programming skills sharp? back in the day I used Glassdoor – an inside look at jobs & companies a lot. You can search for interview questions specific to the role and company you're looking forward to join. Look not only for the questions but also for the experience the candidate had while interviewing. Be warned, though, you'll notice there's a frequent pattern: some people blame the interviewer when they fail. Granted, there are lots of bad interviewers out there, but knowing when to admit that you screwed up is key to learning from your mistakes. Keep that in mind while rummaging through the posts. One can learn a lot from other people's experiences. get a good algorithms book. I used Introduction to Algorithms | The MIT Press by Cormen et al. You might want to skip some or most mathematical proofs of correctness and complexity - they're too dense and time consuming for your purpose. Some purists might say you shouldn't but let's be honest: you're not trying to write a thesis so be pragmatic. You won't benefit much from reading the whole book, focus on the chapters that cover the basics. From the table of contents presented on the link above, I'd read chapters 1-18, skim through 19-20, read 21-24, skim through 25-27, definitely read 32 and skim through 34-35. That's a lot, I know, but that's a solid foundation for everything else you'll encounter. Use your best judgement to decide when to skip stuff. stop whatever you're doing and start reading Programming Pearls by Jon Bentley if you haven't already. Right now. Before anything else. He. Is. King. it might help to brush up the first chapters of a good operating systems book (I used Modern Operating Systems, 2nd. ed.), at least the part about processes, threads, mutexes, semaphores... don't get carried away, though. Since we're in the subject, the short article Mutexes and Semaphores Demystified is a must to read. Semaphores are, IMHO, the single most misunderstood and misused / underused synchronization primitive. when it comes to algorithms you can simply write, compile and run them in your machine. Now systems design is a little harder to study because you need a proper environment to deploy the system, data to process and load to test the corner cases. It helps if you face these problems in your daily work but all is not lost if you don't. There is good material out there. Introduction to Information Retrieval is an awesome book on the subject. Like Cormen's, you probably want to select a few chapters to read because of the limited time you have. I suggest chapters 1-5 so you grasp the basics, that should give you enough background to come up with reasonable, working solutions. there are some basic concepts and algorithms widely used on systems design that you can read about, like: Consistent hashing, Distributed hash table, Paxos (http://research.microsoft.com/en...), Shard (database architecture) another way to study systems design is by reading articles about real systems, like Kademlia. Google has some classic articles on this, namely: Google Research Publication: BigTable, Google Research Publication: MapReduce, The Google File System (the name might be misleading, it's not a general purpose file system, a better rough simplification would be a storage for applications that write data in an append-only or append-mostly fashion - consider a service that logs some activity in real-time, which would later be processed in batch with a MapReduce job), Chubby Distributed Lock Service, Google Research Publication: Paxos Made Live, Megastore: Providing Scalable, Highly Available Storage for Interactive Services... You can also find tons of stuff here: Facebook Engineering How to make progress: start by deciding how much of your day you want to spend on coding, reading about algorithms, solving problems, reading about systems design... Experiment on this and keep calibrating until you find what works best for you since YMMV. whenever you find a new subject, try to identify any dependencies on stuff you haven't already studied. Building a graph of dependencies helps you keep track of stuff (graphviz's dot is your friend: Graphviz - Graph Visualization Software). It helps to know how much is still left to do. keep track of your progress and adjust your plan accordingly: that's how you'll be able to fit everything in the time you have available. Make conscious decisions of when to include or leave something out of your plan. Keep track of how many pages per hour/day of technical stuff you can read, of how many problems per day you can solve... Update this data periodically and use it to make adjustments to your plan. This will also help you with motivation because you'll have clear and concrete metrics on the progress you're making. revisit, from time to time, the problems you already solved and the algorithms and data structures you already implemented. You'll be amazed by how much an individual can forget. Remember, use it or lose it. Our brain learns by repetition. Each time you do it you'll notice that your speed and accuracy will improve. find someone who share your goals. It might not sound very intuitive but explaining stuff is an awesome exercise at understanding and memorizing complex ideas. Discussing solutions also helps with seeing things from a different angle that you're normally biased not to. as a non-exclusive alternative to finding someone to study with you, write your own blog, publish your code or share your experiences online somehow. Chances are someone will benefit from it. If you do a good job you might even get the attention of folks in the companies you wish to join. Just don't get obsessed with this idea because it can deviate you from your plan. build your own software library as you go with data structures and algorithms. Whenever possible, use your own library. Don't aim for the most reusable, templates/generics enabled state-of-the-art library. Your goal is to simply exercise what you're studying. Library writing is the best way I know to exercise software design. Keep in mind, though: a library without a use case won't be mature enough to help you on this. This video might help: Update: a revised and updated version of this answer can now be found here: How to prepare for a Software Engineering Interview Updated 12 Jun • View Upvotes